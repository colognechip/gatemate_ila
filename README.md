# Integrated logic analyser (ILA) for the GateMate FPGA from Cologne Chip
With the ILA, you can perform in-system debugging of your designs on the GateMate FPGA during runtime. It allows you to capture and analyze all signals of your design as a waveform directly within the FPGA, while it is configured with your design. This means, for example, that you can monitor complex data flows in real-time and troubleshoot errors efficiently without disrupting the normal operation of your system.

## Benefits of the ILA

- Analyze more than 1000 bits from your device under test (DUT).
- A simple, interactive, self-explanatory shell that will guide you through the configuration process of the ILA.
- Analyze signals from your design directly within the FPGA in a waveform format, similar to simulations, using the original names and vector sizes from your design.
- Set up a custom bit pattern across the entire range of all signals you wish to analyze as a trigger, using '1', '0', and 'DC'.
- Utilize the maximum available RAM to extend capture time.
- Define a specific duration time before and after the trigger is activated to capture the signals you are interested in.
- Control the reset state of your DUT from the ILA to capture start-up signals.
- Easily redefine a trigger or a range of triggers to automatically initiate multiple captures in sequence.
- Configure the trigger to detect a rising or falling edge on precisely the signal you want.
- Reconfigure the ILA by adjusting and invoking a JSON file generated by the ILA control program (ILAcop).
JSON

## Table of contents
- [Prerequisites](#prerequisites)
- [Installation](#installation)
  - [Python 3 installation](#python-3-installation)
  - [Installation of ILA](#installation-of-ila)
    - [Repository structure](#repository-structure)
  - [Installation of external python packages](#installation-of-external-python-packages)
  - [Installation of a wave viewer](#installation-of-a-wave-viewer)
    - [GTKWave](#gtkwave)
    - [Other wave viewers](#other-wave-viewers)
- [Basic ILA setup](#basic-ila-setup)
  - [Define Linux access rules for USB](#define-linux-access-rules-for-usb)
- [Hardware setup](#hardware-setup)
- [ILA functionality](#ila-functionality)
  - [Trigger condition](#trigger-condition)
  - [Signal analysis](#signal-analysis)
  - [Frequency analysis](#frequency-analysis)
  - [Capture duration](#capture-duration)
- [Usage](#usage)
  - [ILAcop parameters and options](#ilacop-parameters-and-options)
    - [Change external clock frequency](#change-external-clock-frequency)
    - [Phase shift](#phase-shift)
    - [Optimize DUT](#optimize-dut)
    - [Change work dir](#change-work-dir) 
  - [Configuration with the interactive shell](#configuration-with-the-interactive-shell) 
  - [Create JSON](#create-json)
  - [Reconfiguaration of the ILA using a JSON File](#reconfiguaration-of-the-ila-using-a-json-file)
  - [Restart control of the ILA on the FPGA at runtime](#restart-control-of-the-ila-on-the-fpga-at-runtime)
  - [Example of configuration with the interactive shell](#example-of-configuration-with-the-interactive-shell)
  - [Control the ILA on the FPGA during runtime using the blink example](#control-the-ila-on-the-fpga-during-runtime-using-the-blink-example)
    - [Setting a trigger](#setting-a-trigger)
    - [Start capture](#start-capture) 
    - [Reset ILA](#reset-ila)
    - [Reset DUT](#reset-dut)
    - [Exit](#exit)
    - [Setting a sequence of triggers](#setting-a-sequence-of-triggers)
  - [JSON File](#json-file)
- [License](#license)


## Prerequisites

The ILA can be used in conjunction with the GateMate FPGA. The digital circuit of the ILA was designed
in the hardware description language Verilog. A Python program controls the configuration of the ILA
with the design under test (DUT) and the communication, as well as the interaction between FPGA and
user during the debugging process. 

`Python3` with additional packages is required for the execution of user
software. Further software, such as the GateMate FPGA toolchain and GTKWave, is also required to execute
the ILA.

:point_up: **Please Note!** It is assumed in this document
1. that the reader has developed an FPGA design and wants to use it on the GateMate FPGA.
2. that the use of the GateMate FPGA, along with Yosys and Place & Route, is well-known, and the customer's design has already been loaded into the FPGA using the GateMate toolchain. Otherwise, check the dokument [Toolchain Installation User Guide.](https://www.colognechip.com/docs/ug1002-toolchain-install-latest.pdf)

The ILA can be used both with the GateMate FPGA Evaluation Board and with the customer's own hardware.

- If the GateMate FPGA Evaluation Board is being used, familiarity with the [Evaluation Board Datasheet](https://www.colognechip.com/docs/ds1003-gatemate1-evalboard-latest.pdf) is assumed.
- If customer hardware is used, please note that the ILA requires a USB interface between
the computer and the GateMate FPGA. The FPGA ultimately uses an SPI interface
to communicate with the PCB circuitry. The USB-to-SPI adapter can either be built
on the customer PCB or the GateMate FPGA Programmer can used and connected to the FPGA. Please see [Programmer Board Datasheet] (https://www.colognechip.com/docs/ds1002-gatemate1-programmer-latest.pdf) for more information.

## Installation

### Python 3 installation
Python3 is required to use the ILA Control Program (ILAcop). It is recommended to use at least Python 3.8.

On most Linux systems, `python3` can be installed from the package management software.

For example, users of Debian-based Linux distributions can use the `Advanced Package Tool`:
<pre>
$ > sudo apt-get update
$ > sudo apt install python3
</pre>
Windows users can also install `python3` from the official Microsoft Store. 

More information about the installation of `python3` can be found at: https://www.python.org/downloads/. 

### Installation of ILA
Please download the software from https://github.com/colognechip/gatemate_ila.git into a directory of your choice.

It is recommended to use Git to easily keep the software up to date. For information on how to install Git, check https://github.com/git-guides/install-git.

Example of how to install Git on Linux using apt:
<pre>
$ > sudo apt-get install git
</pre>
Once Git is installed, the following command can be used to clone the Git repository:
<pre>
$ > git clone https://github.com/colognechip/gatemate_ila.git
</pre>

You should now have the source files from the `gatemate_ila` in your working directory, with the following structure:

#### Repository structure

In the following the files of the  ILA and their functions are explained:
- **app:**  
  This folder contains all the files required to run the user application ILAcop.
  -  *ILAcop.py:*  
    This file is the main script from which a user starts the ILAcop. The script handles the passed parameters and starts the processes requested by the user. More information about usage in chapter [Usage](#usage).
  - *config.py:*  
    Here, you can configure the ILA and the tools utilized by it. For more informations see [ILAcop parameters and options](#ilacop-parameters-and-options).
  - *requirements.txt:*  
    This file contains all the Python packages used by the ILAcop. It can be used to install the packages using pip.  For more informations see[Installation of external python packages](#installation-of-external-python-packages) 
  - **save\_config:**  
    All created configurations of the ILA are stored in this folder as a JSON File. The ILA can be configured and stared with the help of this files. The files contain all configurations in plain text and can be edited by the user. More Informations in [Reconfiguaration of the ILA using a JSON File](#reconfiguaration-of-the-ila-using-a-json-file)
  - **vcd\_files:**  
    This folder contains the vcd files created by the ILAcop. The VCD files describe the waveforms of the analyzed signals and can be opened with a waveform viewer like GTKWave.
  - *ILAConfig.py:*  
    This file contains the `ILAConfig` class, which includes all methods for configuring the gateware of the ILA before starting the implementation.
  - *RuntimeInteractionManager.py:*  
    This file implements the `RuntimeInteractionManager` class, which contains all the methods through which the user can communicate with the ILA while the ILA is running on the FPGA.
  - *communication.py:*  
    This file contains the `Communication` class, which controls the Serial Peripheral Interface (SPI) to the ILA.
  - *last\_upload.txt:*  
    This file contains the last configuration of the ILA transferred to the FPGA. With this information, communication with the ILA can be restarted using the last uploaded config.
  - **config\_design:**  
    During the configuration of the ILA, the software creates an edited version of the DUT gateware. These Verilog files are stored in this folder. 
- **example_dut:**  
  In this folder, there are two example designs that demonstrate the functionality of the ILA and can be used for understanding. In the folders of the respective examples **blink** and **gol_image_test_vhdl** you will find further explanations of the design and test procedure.
- **src:**  
  This folder contains the verilog source files of the ILA
- **sim:**  
  This folder contains the test bench, which can be used to simulate the gateware of the ILA.
- **log:**  
  This folder contains the log files generated by `yosys` and `p\_r` when bringing the gateware of both the ILA and DUT to the FPGA.
- **net:**  
  This folder contains the verilog netlist of the gateware of the ILA and DUT generated by `yosys`.
- **p\_r\_out:**  
  This folder contains all files generated by `p\_r` including the post-synthesis netlist of the gateware of both the ILA and DUT. 
- *LICENSE:*  
  The *LICENSE* file specifies the legal terms under which the contents of the repository can be used, modified, and distributed.


### Installation of external python packages
The ILA file app/requirements.txt contains a list of external Python packages that
are required for the execution of ILAcop. These packages are:
- numpy
- pyftdi
- pyvcd
- prettytable

One way to install the requirement is to use the python package management software `pip`. 

If pip is not present, in some Python versions the module ensurepip is available, which
can be used to install or upgrade pip:
<pre>
$ > python3 -m ensurepip --upgrade
</pre>
Or alternatively, pip can be installed via the operation system package management software. For Debian-based Linux distributions:
<pre>
$ > sudo apt install python3-pip
</pre>

Further information about the installation can be found on: https://pip.pypa.io/en/stable/installation/ 

In the application folder you will find a file named `app/requirements.txt` which allows you to install all required packages with the command:
<pre>
$ > pip3 install -r requirements.txt
</pre>

### Installation of a Wave Viewer

To view the waveform of the signals being analyzed, you need a waveform viewer that is able to:
- Open .vcd files.
- Be callable from the terminal.

#### GTKWave

A very common wave viewer is GTKWave. On Debian-based Linux distributions you can
use the package management software for installation:
<pre>
$ > sudo apt install gtkwave
</pre>
Windows users can download `GTKWave` in a zip file from https://sourceforge.net/projects/gtkwave/files/. 

Extract the files into a folder of your choice. Inside the folder, you will find a `bin` folder with the `gtkwave.exe` file inside. Add the `bin` folder to your system path.

#### Other Wave Viewers

Other wave viewers can also be used if they fulfill the requirements mentioned above. The call of the corresponding programme must be adapted accordingly in the `app/config.py` file:
<pre>
REPRESENTATION_SOFTWARE = ['gtkwave']
REPRESENTATION_FLAGS = ['--save', 'save.gtkw']
</pre>

When customising the call, please note that the software places the vcd file in the call between the `REPRESENTATION_SOFTWARE` and the `REPRESENTATION_FLAGS`.

## Basic ILA setup

The ILAcop has to execute the toolchain applications and GTKWave. 

If you haven't already done so, install the GateMate FPGA toolchain to transfer your design to the GateMate FPGA. You can follow the [Toolchain Installation User Guide.](https://www.colognechip.com/docs/ug1002-toolchain-install-latest.pdf)

The ILAcop must be able to call the execution files from the system path. Ensure that your system can recognize
the following application calls from the system path by using the command line interface:
<pre>
$ > yosys
$ > p_r
$ > openFPGALoader
$ > gtkwave
</pre>
If a command is not found, its path must be entered in the system settings.

Alternatively, you can add the absolute PATH of the respective program to be executed in the `app/config.py` file. This ILA setup file contains some main
settings.

For example, the file could be changed as follows:
<pre>
YOSYS = '/home/dave/cc-toolchain-linux/bin/yosys/yosys'
YOSYS_FLAGS = '-nomx8'
PR = '/home/dave/cc-toolchain-linux/bin/p_r/p_r'
PR_FLAGS = '-cCP +uCIO' # The +uCIO flag must not be removed. The ccf file is automatically appended
UPLOAD = '/home/dave/cc-toolchain-linux/bin/openFPGALoader/openFPGALoader'
UPLOAD_FLAGS = ' -b gatemate_evb_spi -f --verify '
REPRESENTATION_SOFTWARE = '/home/dave/gtkwave/bin/gtkwave'
REPRESENTATION_FLAGS = ['--save', 'save.gtkw']
CON_DEVICE = 'evb' # GateMate Evaluation Board = 'evb', GateMate Programmer = 'pgm' 
CON_LINK = 'ftdi://ftdi:2232h/1' # evb = 'ftdi://ftdi:2232h/1', pgm = 'ftdi://ftdi:232h/1'
</pre>


### Define Linux access rules for USB

To ensure your Python program or the PyFTDI library has access to USB-Serial devices in Ubuntu, you can create a UDEV rule to set the necessary permissions. This involves editing the `/etc/udev/rules.d/99-usb-serial.rules` file. Follow these steps:

1. Edit the UDEV Rules File:
  Open the file for editing using the command:
  <pre>
  sudo nano /etc/udev/rules.d/99-usb-serial.rules
  </pre>

2. Find `idVendor` and `idProduct` of your Device:
  <pre>
  > lsusb
  Bus 001 Device 003: ID 0403:6010 Future Technology Devices International, Ltd FT2232C/D/H Dual UART/FIFO IC
  </pre>
  In this example, 0403 is the idVendor and 6010 is the idProduct.

3. Add a UDEV Rule:
  Add a rule to set permissions for the device. For example:
  <pre>
  SUBSYSTEM=="usb", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6010", MODE="0666"
  </pre>
  - SUBSYSTEM=="usb" targets USB devices.
  - ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6001" specifies the device using its vendor and product IDs. Replace these with the actual IDs of your USB-Serial device, which you can find using lsusb.
  - MODE="0666" sets the permissions to read and write for everyone. This is suitable for development but considersecurity implications for production environments.

4. Save and Exit:  
  Save the file and exit the editor (Ctrl + X, then Y, and Enter in Nano).

5. Reload UDEV Rules:  
  After adding the rule, reload the UDEV rules to apply the changes:
  <pre>
  sudo udevadm control --reload-rules
  sudo udevadm trigger
  </pre>

This should set the permissions for your USB-Serial device, allowing your Python program and the PyFTDI library to access it.
  



## Hardware setup

The software for the configuration of the GateMate FPGA, as well as the respective programming mode, can be customised in `app/config.py` under the following constants:

<pre>
UPLOAD = 'openFPGALoader'
UPLOAD_FLAGS = ' -b gatemate_evb_jtag '
</pre>
  
If you use the evaluation board, check if the correct programming mode has been selected on the Board. The program is defaulted to the GateMate evaluation board and configures it directly via jtag.

The programming mode options for the openFPGALoader can be found under: https://trabucayre.github.io/openFPGALoader/vendors/colognechip.html.

The gateware of the ILA communicates with the ILAcop via SPI in passive mode. The hardware connected via USB should therefore be able to establish a SPI communication.

In the `app/config.py` file are predefined configurations for the original [evaluation board](https://colognechip.com/docs/ds1003-gatemate1-evalboard-latest.pdf) and the original [GateMate programmer](https://colognechip.com/docs/ds1002-gatemate1-programmer-latest.pdf) from Cologne Chip.

The configurations are set by default on the evaluation board. To set these on the programmer, the following constants must be changed accordingly:

<pre>
UPLOAD_FLAGS = ' -b gatemate_pgm'
CON_DEVICE = 'pgm'
CON_LINK = 'ftdi://ftdi:232h/1'
</pre>

If your own hardware is used, the constants must be adjusted accordingly.

If your own hardware has level shifters before the FPGA, which are activated via the IOs of an FTDI, the following parameters must also be adjusted:
<pre>
CON_DEVICE = 'cust'
cust_gpio_direction_pins = 0x17F0
cust_gpio_direction = 0x1710
cust_gpio_write = 0x0210
</pre>
If no level shifter needs to be activated, set `CON_DEVICE = 'free'`.

The pins used by the SPI-passive controller of the gateware to communicate with the ILA cop can be adjusted in the file `src/ILA_top.ccf` and are located by default at the pins:
<pre>
Pin_in   "i_sclk_ILA"     Loc = "IO_WA_A5" | SCHMITT_TRIGGER=true;   
Pin_in   "i_mosi_ILA"  	  Loc = "IO_WA_A4";
Pin_out  "o_miso_ILA"     Loc = "IO_WA_B3";
Pin_in   "i_ss_ILA"  	    Loc = "IO_WA_B4";
</pre>

If you want to see all the connected Links on your PC, you can do this in the **app** folder by the following program call:
<pre>
python3 .\ILAcop.py --showdev
</pre>
All available interfaces are displayed as follows:
<pre>
Available interfaces:
	ftdi://ftdi:2232:E1-31B0220/1   (GateMate FPGA Evalboard 3.1B)
	ftdi://ftdi:2232:E1-31B0220/2   (GateMate FPGA Evalboard 3.1B)
</pre>

In this case, the dual port FTDI of the GateMate evaluation board is displayed.

You can also set flags for `yosys` and `p\_r` in the *config.py* file.
<pre>
YOSYS = 'yosys'
YOSYS_FLAGS = '-nomx8'
PR = 'p_r'
PR_FLAGS = '-cCP +uCIO' # The removal of the +uCIO flag is not permissible. The ccf file is automatically appended
</pre> 

The command `+uCIO` switches the configuration GPIO bank of the FPGAS so that these can be used as normal user IOs. This is necessary for the ILA to be able to communicate via the same connection as it was configured.

If you have selected other IOs for the SPI communication of the ILA gateware, the '+uCIO' flag can also be omitted.
## ILA functionality

### Trigger condition

ILA has two ways of specifying a trigger condition:
- Any signal can be used as a trigger on its falling or rising edge.
- In addition, any number of signals can be selected and a pattern comparison triggers the measurement when all selected signals have reached the previously defined value.

The trigger condition is specified in the interactive shell before the DUT gets active. It can
be changed, stopped or re-activated during runtime by the user.

When the trigger has fired, the data recording is executed and the data is automatically
downloaded to the computer and displayed in the wave viewer. When the data recording is
finished, the trigger is stopped and can (depending on the configuration) be automatically
re-activated after the end of the data transmission. It can be set whether it is the same
trigger condition or a different one. A list of trigger conditions can be entered, which is
processed one after the other. At the end of the list, ILA stops recording data.

With the pattern compare function, a pattern can be applied across the entire width of
the sample, determining the state of each bit. For each individual bit, it can be decided
whether, at the time of triggering, it should be ’1’, ’0’, or ’DC’ (don’t care).

The pattern compare function can only be set with a sample width of 5 bits or more.

The pattern compare function can be switched on or off when configuring the ILA. If the function is switched off, it is not available for the user at runtime.
If this function is activated, more hardware is required for the ILA gateware and the maximum possible sampling frequency may be reduced.


### Signal analysis

The user can select more than 1000 bits from the signals in the DUT to be analyzed, depending on the RAMs in use by the DUT.

These can be individual signals or signal vectors.
It is also possible to select only partial sections of signal vectors. All selected signals are combined in a sample.

To select a specific range of a vector, specify two natural numbers representing the bit positions. These numbers must lie within the valid range of the vector. The order in which you specify these numbers should correspond to the vector's definition. For instance, if the vector is defined as `a[15:0]`, select the range with the higher value first, e.g., `10:3`. For a vector like `b[0:15]`, the order would be reversed, e.g., `3:10`. Choose your indices in accordance with the vector's definition:

Individual signals are simply indicated with the respective index. Several individual signals and ranges can also be specified in combination. For this, the indexes and ranges must be separated with a comma. 

For example: `12, 10:8, 4, 2:0`.

### Frequency analysis
The sampling frequency defines the delay between the stored samples.

- The sampling frequency is recommend up to 160MHz.
- The sampling frequency is recommend to be at least twice the highest frequency at which a signal under test changes its state in order to correctly reconstruct the signals.
- It is recommended that the sampling frequency be an integer multiple of the frequency at which the signals under test change their state.

Please note: The higher the sampling frequency, the shorter the period of time that can be captured in a single shot because the random-access memory (RAM) fills up more quickly

### Capture duration
During the ILA's capture process, the samples are stored to the internal block RAMs of the GateMate FPGA for each clock period of the analysis frequency. 
The maximum capture duration depends on the available ram, the width of the sample and the sampling frequency. 

The program determines how much RAM memory is occupied by the DUT. To calculate the free RAM available for the ILA, the RAM occupied by the DUT is subtracted from the total available RAM.

The total number of available RAMs is defined in the `app/config.py` file.
<pre>
available_BRAM = 60 # 20k RAM blocks
</pre>

You have to define two values:

##### capture duration before trigger
This parameter sets the capture duration before the trigger is activated.
##### capture duration after trigger
This parameter sets the capture duration after the trigger is activated.


## Usage

### ILAcop parameters and options

To start the ILAcop, you have to execute the *ILAcop.py* script in the **app** folder.

Make sure the program has rights to access the USB port the FPGA is connected to. For Linux System see [Define Linux access rules for USB](#define-linux-access-rules-for-usb).

With the following command, you can get an overview of the parameters with which the program can be called:
<pre>
$ > python3 ILAcop.py --help
usage: ILAcop.py [-h] [--version] [--clean] [--showdev] [-d [0, 1, 2, 3]] [-opt] [-wd WORK_DIR] {config,start,reconfig} ...

GateMate ILA User tool. With this script, you can configure and execute the ILA with a design under test (DUT).

options:
  -h, --help            show this help message and exit
  --version             show program's version number and exit
  --clean               Deletes all output files created by the program.
  --showdev             Outputs all found FTDI ports.
  -d [0, 1, 2, 3]       Set the phase shift of the sampling frequency. 0 = 0°, 1 = 90°, 2 = 180° and 3 = 270° (default: 2).
  -opt                  This optimizes the design by deleting all unused signals before signal evaluation.
  -wd WORK_DIR          Folder from which Yosys should be started for the synthesis of the Design Under Test.

main_actions:
  {config, start, reconfig}

example usage:
python3 ILAcop.py [Commands]

Commands:
  config:   Configure the ILA. the following options must be included:
             -vlog:    Paths to the Verilog source code files.
             -vhd:  Paths to the VHDL source code files.
             -t:    Top level entity of the design under test.
             -ccf:  Folder containing the .ccf file of the design under test.
             -f:    Defines the external clock frequency (default is 10.0 MHz).
          (optional) Subcommands config:
                create_json: Creates a JSON file in which the logic analyzer can be configured.
            NOTE: Without the subcommand the configurations are requested step by step via the terminal.

  reconfig: configures the ILA based on a JSON file. With this option you have to specify a JSON file with -l [filename].json.

  start     starts the communication to the ILA with the last uploaded config

</pre>

#### Change external clock frequency 
The value for the external frequency can be changed with the flag `-f`.
The frequency is defined in MHz as a floating-point value. The default value is `10.0` MHz.
#### Phase shift
With the parameter `-d` you can set the phase shift of the sampling frequency `0 = 0°, 1 = 90°, 2 = 180° and 3 = 270°`. By default, the phase shift of the sampling frequency is set to `2 = 180°`.
When evaluating the captured samples, it must be taken into account that each PLL has its own digitally controlled oscillator (DCO), which oscillates independently. The exact sampling point can therefore vary within the period of a selected sampling frequency. However, the user is able to shift the sampling frequency by 90, 180 or 270 degrees in order to shift the sampling point. 
For example: A sampling frequency of 80 MHz results in a period of 12.5 ns. The sample point can be shifted in four 3.125 ns steps. 

#### Optimize DUT

Passing the `-opt` parameter causes an optimization of the DUT before the ILAcop searches for signals to be tested. This process removes unused signals, which will not be displayed.

#### Change work dir

If there is an indirect path within your design, for example a call like `initial $readmemh("mem/mem.hex", memory);`, please enter the root directory from which the file is referenced with the flag -wd <WORK_DIR>.

#### Clean 

The --clean parameter ensures that all files created by the ILAcop are deleted.

<pre>
gatemate_ila\app> python3 ILAcop.py --clean
All files in directory ../net/ deleted.
All files in directory ../log/ deleted.
All files in directory save_config/ deleted.
All files in directory ../p_r_out/ deleted.
All files in directory vcd_files/ deleted.
All files in directory config_design/ deleted.
</pre>


### Configuration with the interactive shell

In the following example, the interactive shell is started to configure the ILA with a DUT step by step:
<pre>
$ > python3 ILAcop.py config -vlog &lt;your_design_src&gt; -t &lt;top_level_entity&gt;
</pre>

You can pass Verilog source code using the `-vlog` flag and VHDL source code using the `-vhd` flag to reference the source code of the DUT. Using the flag, provide one or more paths to directories containing the respective source code files. The program will search for all Verilog or VHDL files and build the design.

The agument `-t` must be used to specify the top level entity of the DUT.

If the constraints  file is not in the same folder as the given source code, you also have to add a folder with the `.ccf` file of your design with the flag `-ccf`.

### Create JSON

It is also possible to create a JSON file with a DUT, from which configurations such as the signals under test and the sampling frequency can be set.

<pre>
$ > python3 ILAcop.py config -vlog &lt;your_design_src&gt; -t &lt;top_level_entity&gt; -create_json
</pre>

In the generated JSON file, at least the sampling frequency in MHz must be entered as a decimal number with a dot separator, formatted as a string, and at least one signal must be selected for analysis. More information about the JSON file in: [JSON File](#json-file).

### Reconfiguaration of the ILA using a JSON File

Every time the ILA was configured with the interactive shell, the configuration is stored in a JSON file. You are able to edit the file and reconfigure the ILA with the configurations defined inside the JSON file. 

With the following command, the ILA can be reconfigured using the JSON file:
<pre>
$ > python3 ILAcop.py reconfig -l ila_config_name_year_month_day_hour_minute_second.json
</pre>

If a reconfiguration is performed, the capture duration before and after trigger must be redefined, because the capture times may change due to changes in the signals and frequency to be analysed.

### Restart control of the ILA on the FPGA at runtime
The communication with the ILA can be restarted at any time after it has been terminated with the following command:
<pre>
$ > python3 ILAcop.py start 
</pre>
The user software remembers the last configuration of the FPGA, reconfigures the FPGA, and starts communication with the gateware of the ILA.

### Example of configuration with the interactive shell

This section provides step-by-step instructions on how to configure ILA with the interactive shell using the example design `ws2812_gol.vhd`. The design and a more detailed explanation of the design can be found in: [example_dut/ws2812_gol](example_dut/ws2812_gol)

First, the program displays the found constraints file, all source code files, and the ports of the top-level entity of the DUT.

<pre>
gatemate_ila\app> python3 ILAcop.py config -vhd ..\example_dut\gol_image_test_vhdl\src -t ws2812_gol

################ ccf File ##################
#                                           #
# ws2812_gol.ccf                            #
#                                           #
#############################################


################ vhdl Files #################
#                                           #
# aserial.vhd                               #
# edge_detection.vhd                        #
# gol_8x8_control.vhd                       #
# gol_cell.vhd                              #
# init_package.vhd                          #
# ram.vhd                                   #
# ram_to_bit.vhd                            #
# receive_command.vhd                       #
# spi_slave.vhd                             #
# ws2812_gol.vhd                            #
#                                           #
#############################################

Examine DUT ...


################ RAM in use #################
#                                           #
# CC_BRAM_20K in use: 1                     #
# CC_BRAM_40K in use: 0                     #
#                                           #
#############################################

----- Ports DUT "ws2812_gol" ------
+---+--------+-------+------------+
| # |  type  | range |    Name    |
+---+--------+-------+------------+
| 0 | input  |   1   |    clk     |
| 1 | input  |   1   |   i_mosi   |
| 2 | input  |   1   |   i_sclk   |
| 3 | input  |   1   |    i_ss    |
| 4 | input  |   1   |   reset    |
| 5 | output | [7:0] |    led     |
| 6 | output |   1   |   o_miso   |
| 7 | output |   1   | ws2812_out |
+---+--------+-------+------------+

!!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                              !
! Now you will be guided through the configuration of the ILA. !
! Entering 'e' exits the process and generates a configurable  !
! JSON file for the given DUT.                                 !
! Enter 'p' for 'previous' to backtrack a step.                !
!                                                              !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                                    !
! The clk-source is crucial, as they also serve as the ILA's source. !
! The ILA gateware expects a frequency of 10 MHz by default.         !
! If the frequency deviates, change the input frequency value        !
! with the -f parameter when starting the program.                   !
!                                                                    !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


############ CONFIGURATION NOTE #############
#                                           #
# clk source:    "clk"                      #
#                                           #
#############################################

Do you want to change the clk source? (y:yes/N:no)
</pre>
The DUT is examined by constructing it from the provided sources, allowing for the identification of the signals to be analyzed. Since ILAcop uses all block RAMs not used by DUT for storage, the block RAMs used by the DUT are also analyzed and output.

Entering `e` will exit the process and create a JSON file for the given DUT, allowing configurations to be made directly within the file.

Afterwards, you'll have the flexibility to refine the configurations within the generated JSON file and directly set up the ILA from it.

With `p` for 'previous' you can go back one configuration step.

Than the program automatically tries to find the clock Input sources of the DUT by using keywords. The first input signal within the keywords `'clk', 'clock'` in its name is automatically set as the clk-source. The first interaction with the user involves checking whether the program has identified the correct signal as the clock source. If not, the user must press `y` and select the clock source from all the ports listed above.

<pre>

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                                !
! The ILA can hold the DUT in reset until capture starts.        !
! This makes it possible to capture the start process of the DUT !
!                                                                !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


######################## Found external reset input ########################
#                                                                          #
# A potential external reset input signal has been identified,             #
# which can be used to keep the DUT in reset mode via the ILA, if desired. #
# Name of the signal: 'reset'                                              #
#                                                                          #
############################################################################

Would you like to set a different input signal as a user-controllable reset? (y:yes/N:no)

</pre>

A user can activate and deactivate the reset of the DUT while the ILA is running.
Therefore the programme first searches for the primitive `CC_USR_RSTN`. For more information about the primitive see: [GateMate FPGA User Guide Primitives Library](https://www.colognechip.com/docs/ug1001-gatemate1-primitives-library-latest.pdf). 

If the primitive is found, its output signal is linked to the reset control signal of the ILA so that this signal can be controlled by the user in the menu of the ILAcop at runtime.   

If the primitive is not found, an external reset input is searched for. The key words `'rst', 'res'` are used to search for an input name that contains this substring.

If no signal for reset was found automatically, the user can either define a signal manually or select no signal, in this case the function is not available for the user.

Next, all signals found in the DUT are listed.

<pre>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                                                                 !
! You will be prompted to select signals for analysis from those found in your design under test. !
!                                                                                                 !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

--------------------------------- ws2812_gol ----------------------------------
+------+----------------------+---------+----------+--------------------------+
|    # | name                 |  range  | selected | hierarchy                |
+------+----------------------+---------+----------+--------------------------+
|    1 | byte_receive         |  [7:0]  |    []    |                          |
|    2 | byte_send            |  [7:0]  |    []    |                          |
|    3 | clk                  |    1    |    []    |                          |
...
|   38 | gol_init             |    1    |    []    | \golx64.                 |
|   39 | gol_next_gen         |    1    |    []    | \golx64.                 |
|   40 | init_pattern         |  [63:0] |    []    | \golx64.                 |
|   41 | life_out             |  [99:0] |    []    | \golx64.                 |
...
|   46 | rgb_color            |  [1:0]  |    []    | \golx64.                 |
|   47 | shift_life_row       |  [7:0]  |    []    | \golx64.                 |
...
|   59 | ws2812_ram_addr_wr   |  [7:0]  |    []    | \golx64.                 |
...
|   62 | ws2812_rgb_byte_reg  |  [7:0]  |    []    | \golx64.                 |
...
| 1166 | shift_rgb_byte       |  [7:0]  |    []    | \ram_to_bit.             |
...
| 1171 | ws2812_ram_addr_rd   |  [7:0]  |    []    | \ram_to_bit.             |
...
| 1175 | data_out             |    1    |    []    | \ram_to_bit.aserial.     |
...
| 1210 | start_1              |    1    |    []    | \write_bram_rec_cmd.     |
| 1211 | start_2              |    1    |    []    | \write_bram_rec_cmd.     |
+------+----------------------+---------+----------+--------------------------+

## Number of selected bits to be analysed ###
#                                           #
# 0 (max. 1180)                             #
#                                           #
#############################################

Which signals should be analyzed (0 = finish)? 41
</pre>

To make it easier to find the signals, they are sorted alphabetically according to their place in the hirachie of the DUT.

The user is prompted to select the signals to be analyzed. When the user selects a signal vector, he can choose to use the entire vector, specific individual signals, subsections of the vector, or a combination of individual signals and subsections within the vector's range.

<pre>

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                                                  !
! Define a range for the vector to be analyzed.                                    !
!  you can do this in the following ways:                                          !
!   1) Press enter to analyze the entire vector                                    !
!   2) Define an area of the vector. (The area should be within the vector area):  !
!        e.g.: '[1:0]'                                                             !
!   3) Individual signals:                                                         !
!        e.g.: '1'                                                                 !
!   4) Any combination of areas and individual signals                             !
!        e.g.: '9, [7:5], 3, [1:0]'                                                !
! define Signals in descending order!                                              !
!                                                                                  !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

wire [99:0] life_out: 88:81, 78:71, 68:61, 58:51, 48:41, 38:31, 28:21, 18:11

-------------------------------------- ws2812_gol ---------------------------------------
+------+----------------------+---------+--------------------+--------------------------+
|    # | name                 |  range  |      selected      | hierarchy                |
+------+----------------------+---------+--------------------+--------------------------+
|    1 | byte_receive         |  [7:0]  |         []         |                          |
|    2 | byte_send            |  [7:0]  |         []         |                          |
|    3 | clk                  |    1    |         []         |                          |
...
|   38 | gol_init             |    1    |         []         | \golx64.                 |
|   39 | gol_next_gen         |    1    |         []         | \golx64.                 |
|   40 | init_pattern         |  [63:0] |         []         | \golx64.                 |
|   41 | life_out             |  [99:0] | ['88:81', '78:71', | \golx64.                 |
|      |                      |         |  '68:61', '58:51', |                          |
|      |                      |         |  '48:41', '38:31', |                          |
|      |                      |         |  '28:21', '18:11'] |                          |
|   42 | life_shift_cnt       |  [2:0]  |         []         | \golx64.                 |
...
|   46 | rgb_color            |  [1:0]  |         []         | \golx64.                 |
|   47 | shift_life_row       |  [7:0]  |         []         | \golx64.                 |
...
|   59 | ws2812_ram_addr_wr   |  [7:0]  |         []         | \golx64.                 |
...
|   62 | ws2812_rgb_byte_reg  |  [7:0]  |         []         | \golx64.                 |
...
| 1166 | shift_rgb_byte       |  [7:0]  |         []         | \ram_to_bit.             |
...
| 1171 | ws2812_ram_addr_rd   |  [7:0]  |         []         | \ram_to_bit.             |
...
| 1175 | data_out             |    1    |         []         | \ram_to_bit.aserial.     |
...
| 1210 | start_1              |    1    |         []         | \write_bram_rec_cmd.     |
| 1211 | start_2              |    1    |         []         | \write_bram_rec_cmd.     |
+------+----------------------+---------+--------------------+--------------------------+

## Number of selected bits to be analysed ###
#                                           #
# 64 (max. 1180)                            #
#                                           #
#############################################

Which signals should be analyzed (0 = finish)? 39

--------------------------------- ws2812_gol ----------------------------------
+------+----------------------+---------+----------+--------------------------+
|    # | name                 |  range  | selected | hierarchy                |
+------+----------------------+---------+----------+--------------------------+
|    1 | byte_receive         |  [7:0]  |    []    |                          |
|    2 | byte_send            |  [7:0]  |    []    |                          |
|    3 | clk                  |    1    |    []    |                          |
...
|   38 | gol_init             |    1    |    []    | \golx64.                 |
|   39 | gol_next_gen         |    1    |  ['A']   | \golx64.                 |
|   40 | init_pattern         |  [63:0] |    []    | \golx64.                 |
|   41 | life_out             |  [99:0] |    []    | \golx64.                 |
...
|   46 | rgb_color            |  [1:0]  |    []    | \golx64.                 |
|   47 | shift_life_row       |  [7:0]  |    []    | \golx64.                 |
...
|   59 | ws2812_ram_addr_wr   |  [7:0]  |    []    | \golx64.                 |
...
|   62 | ws2812_rgb_byte_reg  |  [7:0]  |    []    | \golx64.                 |
...
| 1166 | shift_rgb_byte       |  [7:0]  |    []    | \ram_to_bit.             |
...
| 1171 | ws2812_ram_addr_rd   |  [7:0]  |    []    | \ram_to_bit.             |
...
| 1175 | data_out             |    1    |    []    | \ram_to_bit.aserial.     |
...
| 1210 | start_1              |    1    |    []    | \write_bram_rec_cmd.     |
| 1211 | start_2              |    1    |    []    | \write_bram_rec_cmd.     |
+------+----------------------+---------+----------+--------------------------+

## Number of selected bits to be analysed ###
#                                           #
# 65 (max. 1180)                             #
#                                           #
#############################################

Which signals should be analyzed (0 = finish)? 3

...

-------------------------------------- ws2812_gol ---------------------------------------
+------+----------------------+---------+--------------------+--------------------------+
|    # | name                 |  range  |      selected      | hierarchy                |
+------+----------------------+---------+--------------------+--------------------------+
|    1 | byte_receive         |  [7:0]  |         []         |                          |
|    2 | byte_send            |  [7:0]  |         []         |                          |
|    3 | clk                  |    1    |       ['A']        |                          |
...
|   38 | gol_init             |    1    |       ['A']        | \golx64.                 |
|   39 | gol_next_gen         |    1    |       ['A']        | \golx64.                 |
|   40 | init_pattern         |  [63:0] |         []         | \golx64.                 |
|   41 | life_out             |  [99:0] | ['88:81', '78:71', | \golx64.                 |
|      |                      |         |  '68:61', '58:51', |                          |
|      |                      |         |  '48:41', '38:31', |                          |
|      |                      |         |  '28:21', '18:11'] |                          |
|   42 | life_shift_cnt       |  [2:0]  |         []         | \golx64.                 |
...
|   46 | rgb_color            |  [1:0]  |       ['A']        | \golx64.                 |
|   47 | shift_life_row       |  [7:0]  |       ['A']        | \golx64.                 |
...
|   59 | ws2812_ram_addr_wr   |  [7:0]  |       ['A']        | \golx64.                 |
...
|   62 | ws2812_rgb_byte_reg  |  [7:0]  |       ['A']        | \golx64.                 |
...
| 1166 | shift_rgb_byte       |  [7:0]  |       ['A']        | \ram_to_bit.             |
...
| 1171 | ws2812_ram_addr_rd   |  [7:0]  |       ['A']        | \ram_to_bit.             |
...
| 1175 | data_out             |    1    |         []         | \ram_to_bit.aserial.     |
...
| 1210 | start_1              |    1    |         []         | \write_bram_rec_cmd.     |
| 1211 | start_2              |    1    |         []         | \write_bram_rec_cmd.     |
+------+----------------------+---------+--------------------+--------------------------+

## Number of selected bits to be analysed ###
#                                           #
# 110 (max. 1180)                           #
#                                           #
#############################################

Which signals should be analyzed (0 = finish)? 0


</pre>

Signals that have been selected are now marked accordingly in the output list. The `['A']` stands for all and means that the entire vector is analysed. If only a range was specified, it will be displayed accordingly in the row `selected`.



When all signals have been selected, you can continue with the further configuration by entering `0`.

<pre>

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Note !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                                                !
! The sampling frequency determines the rate at which signals are captured.      !
! When choosing the frequency, consider:                                         !
!  - At a minimum, twice the highest frequency of the DUT. (recommended: thrice) !
!  - Harmonious with the frequency of the DUT (an integral multiple larger).     !
! Recommended max. sampling frequency up to 160MHz.                              !
!                                                                                !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Choose a sampling frequency (greater than 0, float, in MHz): 40
</pre>

Afterwards, you have to input the frequency at which the samples should be stored. More Inforamtion about the sampling frequency in section [Frequency analysis](#frequency-analysis).

<pre>
!!!!!!!!!!!!!!!!!!! Note !!!!!!!!!!!!!!!!!!!!
!                                           !
! The capture duration must be defined.     !
! The maximum duration depends on:          !
!  - available ram                          !
!  - width of the sample                    !
!  - sampling frequency                     !
!                                           !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Please choose one of the following durations:
+---+---------+---------------+
| # | smp_cnt | duration [us] |
+---+---------+---------------+
| 1 |       8 |           0.2 |
| 2 |      24 |           0.6 |
| 3 |      56 |           1.4 |
| 4 |     120 |           3.0 |
| 5 |     248 |           6.2 |
| 6 |     504 |          12.6 |
| 7 |    1016 |          25.4 |
| 8 |    2040 |          51.0 |
| 9 |    4088 |         102.2 |
+---+---------+---------------+

Capture duration before trigger activation (choose between 1 and 9): 1

####### Capture duration before Trigger #######
#                                             #
# Sample count = 8                            #
# Capture duration = 0.2 us                   #
#                                             #
###############################################

Please choose one of the following durations:
+----+---------+---------------+
|  # | smp_cnt | duration [us] |
+----+---------+---------------+
|  1 |       8 |           0.2 |
|  2 |      24 |           0.6 |
|  3 |      56 |           1.4 |
|  4 |     120 |           3.0 |
|  5 |     248 |           6.2 |
|  6 |     504 |          12.6 |
|  7 |    1016 |          25.4 |
|  8 |    2040 |          51.0 |
|  9 |    4088 |         102.2 |
| 10 |    8184 |         204.6 |
+----+---------+---------------+

Capture duration after trigger activation (choose between 1 and 10): 10

####### Capture duration after Trigger ########
#                                             #
# Sample count = 8184                         #
# Capture duration = 204.6 us                 #
#                                             #
###############################################

</pre>

The maximum capture duration is calculated based on the sample width and sampling frequency.

The user can select the capture duration before and after the trigger is activated.

More Inforamtion about the capture duration in section [Capture duration](#capture-duration).

<pre>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Note !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                                         !
! There are two default triggers that can be set for exactly one signal:  !
!  'rising edge' and 'falling edge'                                       !
! There is also an optional trigger: pattern compare                      !
! With this option, a pattern can be set across the entire bit width,     !
!  determining for each bit whether it should be '1', '0', or 'dc'        !
!  (don't care) to activate the trigger.                                  !
! If this function is activated, more hardware is required for the ILA    !
!  and the maximum possible sampling frequency may be reduced.            !
!                                                                         !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Would you like me to implement the function for comparing bit patterns? (y/N): y
</pre>

If your selected sample is greater than 4, the pattern compare function can be configured.

With the help of the pattern compare function, bit patterns can be set as triggers over the entire sample. This function can be switched on or off, so that resources are saved for the case that the function is not needed. More inforamtion about the pattern compare function in section [Trigger Condition](#trigger-condition).
<pre>
###### Signals under test ######
#                             #
#  clk                        #
#  gol_init                   #
#  gol_next_gen               #
#  [88:81] life_out           #
#  [78:71] life_out           #
#  [68:61] life_out           #
#  [58:51] life_out           #
#  [48:41] life_out           #
#  [38:31] life_out           #
#  [28:21] life_out           #
#  [18:11] life_out           #
#  [1:0] rgb_color            #
#  [7:0] shift_life_row       #
#  [7:0] ws2812_ram_addr_wr   #
#  [7:0] ws2812_rgb_byte_reg  #
#  [7:0] shift_rgb_byte       #
#  [7:0] ws2812_ram_addr_rd   #
#  data_out                   #
#                             #
###############################

Execute Synthesis...
Output permanently saved to: C:\Users\df\gatemate_ila/log/yosys.log

Execute Implementation...
Output permanently saved to: C:\Users\df\gatemate_ila/log/impl.log


#################### Configuration File ####################
#                                                          #
# save_config/ila_config_ws2812_gol_23-12-02_17-23-46.json #
#                                                          #
############################################################

Upload to FPGA Board...
</pre>
All signals in the defined sample are displayed to the user here.

The synthesis and implementation processes are then executed, and their output is piped into the corresponding files, which are displayed.

Every time the ILA was configured with the interactive shell, the configuration is stored in a JSON file. You are able to edit the file and reconfigure the ILA with the configurations defined inside the file. For more informations see section [Reconfiguaration of the ILA using a JSON File](#reconfiguaration-of-the-ila-using-a-json-file).

The design is uploaded as required and the communication with the gateware is started. How to change the upload mode is explained in section  [Hardware setup](#hardware-setup).


### Control the ILA on the FPGA during runtime using the blink example

When the communication to the ILA gateware has been successfully started, the following output is given to the user:

<pre>
-------- All Signals ---------
+----+-------------+---------+
|  # |        Name | Pattern |
+----+-------------+---------+
|  0 |       clk90 |      dc |
|  1 |      clk270 |      dc |
|  2 |      clk180 |      dc |
|  3 |        clk0 |      dc |
|  4 |         clk |      dc |
|  5 |  counter[0] |      dc |
|  6 |  counter[1] |      dc |
...
| 31 | counter[26] |      dc |
+----+-------------+---------+

##### current ILA runtime configuration #####
#                                           #
# Number of sequences: 1                    #
#                                           #
#  Sequences Number: 1                      #
#     trigger activation: falling edge      #
#     trigger signal:     clk90             #
#                                           #
#############################################

0 -- exit
1 -- change Trigger
2 -- start capture
3 -- reset ILA (resets the config of the ILA)
4 -- reset DUT (hold the DUT in reset until the capture starts)

Enter your choice:
</pre>

A table is printed, in which each bit to be analyzed is listed. The first column contains the number used to reference the respective signal, followed by the name with any vector index. The last column contains the pattern value defined for a trigger, if the pattern compare function is activated.

With the listed menu the user can configure a trigger at runtime.


#### Setting a trigger

By entering `'1'`, the user can define the trigger:

<pre>
Enter your choice: 1

################### Trigger configuration ##################
#                                                          #
# Select how many triggers are set directly in succession. #
# For each iteration you can select a separate trigger.    #
# Entering 'e' exits the process                           #
# Enter 'p' for 'previous' to backtrack a step.            #
#                                                          #
############################################################


Number of sequences (int, > 0): 1

###  sequence nr. 1: ###

All possible Trigger activations:
0:      falling edge
1:      rising edge
2:      pattern

Trigger activation? in range [0-2]: 2

!!!!!!!!!!!!!!!!!!!!!! Pattern as trigger !!!!!!!!!!!!!!!!!!!!!!!
!                                                               !
! Define the Bit-Pattern for Trigger Activation                 !
! Set individual bits using '0' and '1'                         !
! Set up a hex pattern using the key 'h' followed by hex values !
! set all remaining signals to dont care with 'r'               !
! all other inputs set a single signal to dc                    !
!                                                               !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

clk90:
clk270:
clk180:
clk0:
clk:
counter[0]: h280acf
counter[0]: 1
counter[1]: 1
counter[2]: 1
counter[3]: 1
counter[4]: 0
counter[5]: 0
counter[6]: 1
counter[7]: 1
counter[8]: 0
counter[9]: 1
counter[10]: 0
counter[11]: 1
counter[12]: 0
counter[13]: 0
counter[14]: 0
counter[15]: 0
counter[16]: 0
counter[17]: 0
counter[18]: 0
counter[19]: 1
counter[20]: 0
counter[21]: 1
counter[22]: 0
counter[23]: 0
counter[24]: r
</pre>

The following configuration steps must be performed

- **Number of sequences:**
	First, the user has to define how many captures are to be performed in succession. Each capture consists of setting triggers, start capturing, triggering triggers and receiving data. 
	This function can be used to capture events that occur in quick succession. For each sequence a separate trigger can be set. Each capture of an sequence is displayed in its own waveform viewer window.
	
- **Trigger activation:**
	Possible activations are *rising edge*, *falling edge* and *pattern compare*. You have to define the *Trigger activation* for each sequence.
- **Trigger signal:**
    If *rising edge* or *faling edge* is selected as trigger, a single, specific signal must be selected as trigger
		from the table above, select a signal using the number in the first row.
- **Define pattern:**
    If *pattern compare* is selected as trigger, you can specify for each individual bit of the entire pattern whether it should be logically `1`, `0`, or `DC` (Don't Care, representing either `0` or `1`).
    An entry is required for each individual signal. 
		
  Entering `1` or `0` you set the respective bit logically `1` or `0`. 
		
	Entering `h` followed by hexadecimal values you can define a range of the pattern in hexadecimal. Each hex value defines a 4-bit value from the highest bit to the lowest bit.
		
	Entering any other character sets the currently requested bit to `DC`. 
		
	Entering `r` sets all the remaining bits to DC.

  With the `Backspace` key you can go back to the previous signal.

In this example, the signals *clk90*, *clk270*, *clk180*, *clk0* and *clk* were set to `DC` using the enter button.
With the input of `h280acf` a pattern was defined in hexadecimal for bits 0-23 of counter. 
By pressing the enter key, the pattern is converted to binary and written behind the respective signals.
The remaining signals were then set to `DC` by entering the `r` key.

The defined pattern is now displayed in the table and the trigger configurations are shown:

<pre>
-------- All Signals ---------
+----+-------------+---------+
|  # |        Name | Pattern |
+----+-------------+---------+
|  0 |       clk90 |      dc |
|  1 |      clk270 |      dc |
|  2 |      clk180 |      dc |
|  3 |        clk0 |      dc |
|  4 |         clk |      dc |
|  6 |  counter[0] |       1 |
|  7 |  counter[1] |       1 |
|  8 |  counter[2] |       1 |
|  9 |  counter[3] |       1 |
| 10 |  counter[4] |       0 |
| 11 |  counter[5] |       0 |
| 12 |  counter[6] |       1 |
| 13 |  counter[7] |       1 |
| 14 |  counter[8] |       0 |
| 15 |  counter[9] |       1 |
| 16 | counter[10] |       0 |
| 17 | counter[11] |       1 |
| 18 | counter[12] |       0 |
| 19 | counter[13] |       0 |
| 20 | counter[14] |       0 |
| 21 | counter[15] |       0 |
| 22 | counter[16] |       0 |
| 23 | counter[17] |       0 |
| 24 | counter[18] |       0 |
| 25 | counter[19] |       1 |
| 26 | counter[20] |       0 |
| 27 | counter[21] |       1 |
| 28 | counter[22] |       0 |
| 29 | counter[23] |       0 |
| 29 | counter[24] |      dc |
| 30 | counter[25] |      dc |
| 31 | counter[26] |      dc |
+----+-------------+---------+

##### current ILA runtime configuration #####
#                                           #
# Number of sequences: 1                    #
#                                           #
#  Sequences Number: 1                      #
#     trigger activation: pattern           #
#                                           #
#############################################

0 -- exit
1 -- change Trigger
2 -- start capture
3 -- reset ILA (resets the config of the ILA)
4 -- reset DUT (hold the DUT in reset until the capture starts)

Enter your choice: 2
</pre>


#### Start capture
Entering `2` starts the capturing and the ILA waits for the trigger event. By pressing the `Enter` key, capturing can be aborted at any time, allowing for a new trigger to be set.

For each sequence a *vcd file* is created in the folder *vcd\_files*. 
The name of the generated file is composed of the project name, the current date and time, as well as the sequence number. 

After creating the *vcd files*, the wave viewer starts in a separate process for each sequence, and all waveforms are displayed in their own windows.

<pre>

################# start Capture #################
#                                               #
# Waiting for device. Press Enter to interrupt. #
#                                               #
#################################################


############### Duration between captures ##############
#                                                      #
# Duration between start and first trigger: 0.533429 s #
#                                                      #
########################################################


############### create vcd file ###############
#                                             #
# vcd_files/ila_blink_23-12-05_15-54-35_0.vcd #
#                                             #
###############################################


Press Enter to continue

-------- All Signals ---------
+----+-------------+---------+
|  # |        Name | Pattern |
+----+-------------+---------+
|  0 |       clk90 |      dc |
|  1 |      clk270 |      dc |
...
| 31 | counter[26] |      dc |
+----+-------------+---------+

##### current ILA runtime configuration #####
#                                           #
# Number of sequences: 1                    #
#                                           #
#  Sequences Number: 1                      #
#     trigger activation: pattern           #
#                                           #
#############################################



0 -- exit
1 -- change Trigger
2 -- start capture
3 -- reset ILA (resets the config of the ILA)
4 -- reset DUT (hold the DUT in reset until the capture starts)
</pre>

#### Example that shows the generated waveform with GTKwave

![Waveform](example_dut/blink/example_output/ILA_blink_trigger.png)


#### Reset ILA
Entering `3` in the main options menu resets all ILA configurations to their default values.
#### Reset DUT

Entering `4` in the main options menu activate and deactivate the reset of the DUT. When starting the capture, the reset will automatically deactivated.

#### Exit
Entering `0` in the main options menu close the communication with the ILA. The ILA can simply be restarted with the same configuration with:
<pre>
$ > python3 ILAcop.py start 
</pre>

### Setting a sequence of triggers

If more than one trigger is set, the triggers are automatically configured one after the other. 
All sequences are executed in succession. Each sequence runs through the following steps:

1. The defined trigger is set.
2. The capture process is started.
3. The system waits for the trigger to be activated.
4. The requested samples are received

A user can cancel this process at any time; all completed sequences are displayed as waveforms in separate GTKwave windows.

The waveforms of all sequences are displayed in separate windows once they have all been processed.

An example of how a sequence is set and triggered can be found in: [ws2812_gol](example_dut/ws2812_gol)

### JSON File

You can define the analysis signals in the following ways:
<pre>
{
	"Signal_type": "reg",
	"Signal_range": "[127:0]",
	"Signal_name": "data_in",
	"Signal_moduls": "\\encrypt.",
	"selected": [
			"A"
		]
},
{
	"Signal_type": "wire",
	"Signal_range": "[127:0]",
	"Signal_name": "key",
	"Signal_moduls": "\\encrypt.",
	"selected": [
	"127:100"
	]
},
{
	"Signal_type": "wire",
	"Signal_range": "[127:0]",
	"Signal_name": "sub_key",
	"Signal_moduls": "\\encrypt.",
	"selected": [
	"1"
	]
},
{
	"Signal_type": "wire",
	"Signal_range": "[127:0]",
	"Signal_name": "data_out",
	"Signal_moduls": "\\encrypt.",
	"selected": [
			"127:100",
			"88",
			"45:40",
			"10",
			"1"
	]
},
</pre>
With `['A']` you can select the entire vector. You also can specific individual signals, subsections of the vector, or a combination of individual signals and subsections within the vector's range.

Afterwards, the corresponding entries must be added to the created file and the ILA can be started again with `python3 ILAcop.py reconfig -l ila_config_....json`.

## License

This project is licensed under the GNU General Public License. See the [LICENSE](LICENSE) file for details. 

